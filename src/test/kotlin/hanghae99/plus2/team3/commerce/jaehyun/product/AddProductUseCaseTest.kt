package hanghae99.plus2.team3.commerce.jaehyun.product

import hanghae99.plus2.team3.commerce.jaehyun.common.exception.ErrorCode
import hanghae99.plus2.team3.commerce.jaehyun.seller.domain.Seller
import hanghae99.plus2.team3.commerce.jaehyun.seller.exception.SellerException
import hanghae99.plus2.team3.commerce.jaehyun.seller.exception.SellerNameDuplicatedException
import hanghae99.plus2.team3.commerce.jaehyun.seller.mock.FakeSellerRepositoryImpl
import hanghae99.plus2.team3.commerce.jaehyun.seller.mock.SellerMemoryRepository
import hanghae99.plus2.team3.commerce.jaehyun.shop.domain.Shop
import hanghae99.plus2.team3.commerce.jaehyun.shop.domain.ShopRepository
import hanghae99.plus2.team3.commerce.jaehyun.shop.mock.FakeShopRepositoryImpl
import hanghae99.plus2.team3.commerce.jaehyun.shop.mock.ShopMemoryRepository
import org.assertj.core.api.Assertions
import org.assertj.core.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.util.*
import java.util.concurrent.atomic.AtomicLong

/**
 * ProductServiceTest
 *
 * @author jaypark
 * @version 1.0.0
 * @since 2023/09/19
 */
class AddProductUseCaseTest {

    private lateinit var addProductUseCase: AddProductUseCase
    private lateinit var fakeSellerRepository: FakeSellerRepositoryImpl
    private lateinit var fakeShopRepository: FakeShopRepositoryImpl
    private lateinit var fakeProductRepository: FakeProductRepositoryImpl

    @BeforeEach
    fun setUp() {
        fakeSellerRepository = FakeSellerRepositoryImpl(SellerMemoryRepository())
        fakeShopRepository = FakeShopRepositoryImpl(ShopMemoryRepository())
        fakeProductRepository = FakeProductRepositoryImpl(ProductMemoryRepository())
        addProductUseCase = AddProductUseCaseImpl(fakeProductRepository, fakeShopRepository)

        val preSavedSeller = Seller(id = 1L, name = "판매자1")
        val preSavedShop = Shop(id = 1L, name = "상점1", preSavedSeller)
        fakeSellerRepository.save(preSavedSeller)
        fakeShopRepository.save(preSavedShop)
    }

    @Test
    fun `정상적으로 상품 등록을 요청하면 기대하는 응답을 반환한다`() {
        val command: AddProductUseCase.Command = AddProductUseCase.Command(
            name = "상품1",
            price = 1000,
            quantity = 10,
            sellerId = 1L,
            shopId = 1L,
            category = Category.CLOTHES,
        )

        val savedProduct = addProductUseCase.command(command)

        assertThat(savedProduct.id).isNotNull
        assertThat(savedProduct.name).isEqualTo(command.name)
        assertThat(savedProduct.price).isEqualTo(command.price)
        assertThat(savedProduct.quantity).isEqualTo(command.quantity)
        assertThat(savedProduct.sellerId).isEqualTo(command.sellerId)
        assertThat(savedProduct.category).isEqualTo(command.category)
    }

    @Test
    fun `잘못된 sellerId와 shopId로 상품 등록을 요청하면 기대하는 응답(exception)을 반환한다`() {
        val command: AddProductUseCase.Command = AddProductUseCase.Command(
            name = "상품1",
            price = 1000,
            quantity = 10,
            sellerId = 999L,
            shopId = 1L,
            category = Category.CLOTHES,
        )

        assertThatThrownBy {  addProductUseCase.command(command) }
            .isExactlyInstanceOf(InvalidShopInfoException::class.java)
            .hasMessage(ErrorCode.INVALID_SHOP_INFO.message)
    }
}

interface AddProductUseCase {
    fun command(command: Command) : Product

    data class Command(
        val name: String,
        val price: Int,
        val quantity: Int,
        val sellerId: Long,
        val shopId: Long,
        val category: Category,
    )
}

class AddProductUseCaseImpl(
    private val productRepository: ProductRepository,
    private val shopRepository: ShopRepository,
) : AddProductUseCase {

    override fun command(command: AddProductUseCase.Command)
    : Product {
        shopRepository.findByIdAndSellerId(command.shopId, command.sellerId)
            ?: throw InvalidShopInfoException()

        val product = Product(
            name = command.name,
            price = command.price,
            quantity = command.quantity,
            sellerId = command.sellerId,
            shopId = command.shopId,
            category = command.category,
        )
        return productRepository.save(product)
    }
}

interface ProductRepository {
    fun save(product: Product): Product
}

class FakeProductRepositoryImpl(
    private val productMemoryRepository: ProductMemoryRepository,
) : ProductRepository {
    override fun save(product: Product) : Product {
        return productMemoryRepository.save(product)
    }
}

class ProductMemoryRepository {
    private val autoGeneratedId = AtomicLong(0)
    private val products = Collections.synchronizedList(mutableListOf<ProductEntity>())

    fun save(product: Product): Product {
        val entity = ProductEntity(
            id = autoGeneratedId.incrementAndGet(),
            name = product.name,
            price = product.price,
            quantity = product.quantity,
            sellerId = product.sellerId,
            shopId = product.shopId,
            category = product.category,
        )
        products.add(entity)
        return product.copy(id = entity.id)
    }
}
class ProductEntity(
    id: Long?,
    name: String,
    price: Int,
    quantity: Int,
    sellerId: Long,
    shopId: Long,
    category: Category,
){
    val id: Long = id ?: 0L

    var name: String = name
        private set

    var price: Int = price
        private set

    var quantity: Int = quantity
        private set

    var sellerId: Long = sellerId
        private set

    var shopId: Long = shopId
        private set

    var category: Category = category
        private set
}

data class Product(
    val id: Long = 0,
    val name: String,
    val price: Int,
    val quantity: Int,
    val sellerId: Long,
    val shopId: Long,
    val category: Category,
) {
    init {
        require(name.isNotBlank()) { "상품 이름은 필수입니다." }
        require(price >= 0) { "잘못된 상품 가격입니다." }
        require(quantity >= 0) { "상품 수량이 0개 미만입니다." }
        require(sellerId >= 0) { "잘못된 판매자 ID 입니다." }
        require(shopId >= 0) { "잘못된 상점 ID 입니다." }
    }
}


enum class Category {
    CLOTHES,
}


open class ProductException(
    errorCode: ErrorCode
) : RuntimeException(errorCode.message)

class InvalidShopInfoException : ProductException(ErrorCode.INVALID_SHOP_INFO)



